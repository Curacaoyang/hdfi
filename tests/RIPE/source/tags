!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ATTACK_FORM	ripe_attack_generator.h	/^typedef struct attack_form ATTACK_FORM;$/;"	t	typeref:struct:attack_form
ATTACK_IMPOSSIBLE	ripe_attack_parameters.h	23;"	d
ATTACK_NOT_IMPLEMENTED	ripe_attack_parameters.h	24;"	d
BSS	ripe_attack_parameters.h	/^enum locations     {STACK=400, HEAP, BSS, DATA};$/;"	e	enum:locations
CHARPAYLOAD	ripe_attack_generator.h	/^typedef struct char_payload CHARPAYLOAD;$/;"	t	typeref:struct:char_payload
CREATE_FILE	ripe_attack_parameters.h	/^                    INJECTED_CODE_POLY_NOP, RETURN_INTO_LIBC, CREATE_FILE, RETURN_ORIENTED_PROGRAMMING};$/;"	e	enum:inject_params
DATA	ripe_attack_parameters.h	/^enum locations     {STACK=400, HEAP, BSS, DATA};$/;"	e	enum:locations
DEBUG_MEMDUMP	ripe_attack_generator.h	44;"	d
DEFAULT_DUMP_SIZE	ripe_attack_generator.h	41;"	d
DIRECT	ripe_attack_parameters.h	/^enum techniques    {DIRECT=100, INDIRECT};$/;"	e	enum:techniques
FALSE	ripe_attack_generator.h	/^enum booleans {FALSE=0, TRUE};$/;"	e	enum:booleans
FSCANF	ripe_attack_parameters.h	/^                    STRCAT, STRNCAT, SSCANF, FSCANF, HOMEBREW};$/;"	e	enum:functions
FUNC_PTR_BSS	ripe_attack_parameters.h	/^		    FUNC_PTR_HEAP, FUNC_PTR_BSS, FUNC_PTR_DATA,$/;"	e	enum:code_ptrs
FUNC_PTR_DATA	ripe_attack_parameters.h	/^		    FUNC_PTR_HEAP, FUNC_PTR_BSS, FUNC_PTR_DATA,$/;"	e	enum:code_ptrs
FUNC_PTR_HEAP	ripe_attack_parameters.h	/^		    FUNC_PTR_HEAP, FUNC_PTR_BSS, FUNC_PTR_DATA,$/;"	e	enum:code_ptrs
FUNC_PTR_STACK_PARAM	ripe_attack_parameters.h	/^		    FUNC_PTR_STACK_VAR, FUNC_PTR_STACK_PARAM,$/;"	e	enum:code_ptrs
FUNC_PTR_STACK_VAR	ripe_attack_parameters.h	/^		    FUNC_PTR_STACK_VAR, FUNC_PTR_STACK_PARAM,$/;"	e	enum:code_ptrs
HEAP	ripe_attack_parameters.h	/^enum locations     {STACK=400, HEAP, BSS, DATA};$/;"	e	enum:locations
HEX_STRING_SIZE	ripe_attack_generator.h	42;"	d
HOMEBREW	ripe_attack_parameters.h	/^                    STRCAT, STRNCAT, SSCANF, FSCANF, HOMEBREW};$/;"	e	enum:functions
INDIRECT	ripe_attack_parameters.h	/^enum techniques    {DIRECT=100, INDIRECT};$/;"	e	enum:techniques
INJECTED_CODE_NO_NOP	ripe_attack_parameters.h	/^enum inject_params {INJECTED_CODE_NO_NOP=200, INJECTED_CODE_SIMPLE_NOP,$/;"	e	enum:inject_params
INJECTED_CODE_POLY_NOP	ripe_attack_parameters.h	/^                    INJECTED_CODE_POLY_NOP, RETURN_INTO_LIBC, CREATE_FILE, RETURN_ORIENTED_PROGRAMMING};$/;"	e	enum:inject_params
INJECTED_CODE_SIMPLE_NOP	ripe_attack_parameters.h	/^enum inject_params {INJECTED_CODE_NO_NOP=200, INJECTED_CODE_SIMPLE_NOP,$/;"	e	enum:inject_params
LONGJMP_BUF_BSS	ripe_attack_parameters.h	/^                    LONGJMP_BUF_HEAP, LONGJMP_BUF_BSS, LONGJMP_BUF_DATA,$/;"	e	enum:code_ptrs
LONGJMP_BUF_DATA	ripe_attack_parameters.h	/^                    LONGJMP_BUF_HEAP, LONGJMP_BUF_BSS, LONGJMP_BUF_DATA,$/;"	e	enum:code_ptrs
LONGJMP_BUF_HEAP	ripe_attack_parameters.h	/^                    LONGJMP_BUF_HEAP, LONGJMP_BUF_BSS, LONGJMP_BUF_DATA,$/;"	e	enum:code_ptrs
LONGJMP_BUF_STACK_PARAM	ripe_attack_parameters.h	/^		    LONGJMP_BUF_STACK_VAR, LONGJMP_BUF_STACK_PARAM,$/;"	e	enum:code_ptrs
LONGJMP_BUF_STACK_VAR	ripe_attack_parameters.h	/^		    LONGJMP_BUF_STACK_VAR, LONGJMP_BUF_STACK_PARAM,$/;"	e	enum:code_ptrs
MEMCPY	ripe_attack_parameters.h	/^enum functions     {MEMCPY=500, STRCPY, STRNCPY, SPRINTF, SNPRINTF,$/;"	e	enum:functions
MEM_DUMP	ripe_attack_generator.h	/^typedef struct memory_dump MEM_DUMP;$/;"	t	typeref:struct:memory_dump
OLD_BASE_PTR	ripe_attack_parameters.h	/^enum code_ptrs     {RET_ADDR=300, OLD_BASE_PTR, $/;"	e	enum:code_ptrs
OLD_BP_PTR	ripe_attack_generator.c	289;"	d	file:
RETURN_INTO_LIBC	ripe_attack_parameters.h	/^                    INJECTED_CODE_POLY_NOP, RETURN_INTO_LIBC, CREATE_FILE, RETURN_ORIENTED_PROGRAMMING};$/;"	e	enum:inject_params
RETURN_ORIENTED_PROGRAMMING	ripe_attack_parameters.h	/^                    INJECTED_CODE_POLY_NOP, RETURN_INTO_LIBC, CREATE_FILE, RETURN_ORIENTED_PROGRAMMING};$/;"	e	enum:inject_params
RET_ADDR	ripe_attack_parameters.h	/^enum code_ptrs     {RET_ADDR=300, OLD_BASE_PTR, $/;"	e	enum:code_ptrs
RET_ADDR_PTR	ripe_attack_generator.c	290;"	d	file:
RIPE_ATTACK_GENERATOR_H	ripe_attack_generator.h	21;"	d
RIPE_ATTACK_PARAMETERS_H	ripe_attack_parameters.h	21;"	d
SNPRINTF	ripe_attack_parameters.h	/^enum functions     {MEMCPY=500, STRCPY, STRNCPY, SPRINTF, SNPRINTF,$/;"	e	enum:functions
SPRINTF	ripe_attack_parameters.h	/^enum functions     {MEMCPY=500, STRCPY, STRNCPY, SPRINTF, SNPRINTF,$/;"	e	enum:functions
SSCANF	ripe_attack_parameters.h	/^                    STRCAT, STRNCAT, SSCANF, FSCANF, HOMEBREW};$/;"	e	enum:functions
STACK	ripe_attack_parameters.h	/^enum locations     {STACK=400, HEAP, BSS, DATA};$/;"	e	enum:locations
STRCAT	ripe_attack_parameters.h	/^                    STRCAT, STRNCAT, SSCANF, FSCANF, HOMEBREW};$/;"	e	enum:functions
STRCPY	ripe_attack_parameters.h	/^enum functions     {MEMCPY=500, STRCPY, STRNCPY, SPRINTF, SNPRINTF,$/;"	e	enum:functions
STRNCAT	ripe_attack_parameters.h	/^                    STRCAT, STRNCAT, SSCANF, FSCANF, HOMEBREW};$/;"	e	enum:functions
STRNCPY	ripe_attack_parameters.h	/^enum functions     {MEMCPY=500, STRCPY, STRNCPY, SPRINTF, SNPRINTF,$/;"	e	enum:functions
STRUCT_FUNC_PTR_BSS	ripe_attack_parameters.h	/^		    STRUCT_FUNC_PTR_DATA,STRUCT_FUNC_PTR_BSS$/;"	e	enum:code_ptrs
STRUCT_FUNC_PTR_DATA	ripe_attack_parameters.h	/^		    STRUCT_FUNC_PTR_DATA,STRUCT_FUNC_PTR_BSS$/;"	e	enum:code_ptrs
STRUCT_FUNC_PTR_HEAP	ripe_attack_parameters.h	/^		    STRUCT_FUNC_PTR_STACK,STRUCT_FUNC_PTR_HEAP,$/;"	e	enum:code_ptrs
STRUCT_FUNC_PTR_STACK	ripe_attack_parameters.h	/^		    STRUCT_FUNC_PTR_STACK,STRUCT_FUNC_PTR_HEAP,$/;"	e	enum:code_ptrs
TRUE	ripe_attack_generator.h	/^enum booleans {FALSE=0, TRUE};$/;"	e	enum:booleans
_GNU_SOURCE	ripe_attack_generator.h	23;"	d
address	ripe_attack_generator.h	/^  char address[HEX_STRING_SIZE];$/;"	m	struct:memory_dump	access:public
attack	ripe_attack_generator.c	/^static ATTACK_FORM attack;$/;"	v	file:
attack_form	ripe_attack_generator.h	/^struct attack_form {$/;"	s
attack_form::code_ptr	ripe_attack_generator.h	/^  enum code_ptrs code_ptr;$/;"	m	struct:attack_form	typeref:enum:attack_form::code_ptrs	access:public
attack_form::function	ripe_attack_generator.h	/^  enum functions function;$/;"	m	struct:attack_form	typeref:enum:attack_form::functions	access:public
attack_form::inject_param	ripe_attack_generator.h	/^  enum inject_params inject_param;$/;"	m	struct:attack_form	typeref:enum:attack_form::inject_params	access:public
attack_form::location	ripe_attack_generator.h	/^  enum locations location;$/;"	m	struct:attack_form	typeref:enum:attack_form::locations	access:public
attack_form::technique	ripe_attack_generator.h	/^  enum techniques technique;$/;"	m	struct:attack_form	typeref:enum:attack_form::techniques	access:public
attackme	ripe_attack_generator.h	/^struct attackme{$/;"	s
attackme::buffer	ripe_attack_generator.h	/^    char buffer[256];$/;"	m	struct:attackme	access:public
attackme::func_ptr	ripe_attack_generator.h	/^    int (*func_ptr)(const char *, int);$/;"	m	struct:attackme	access:public
boolean	ripe_attack_generator.h	/^typedef int boolean;$/;"	t
booleans	ripe_attack_generator.h	/^enum booleans {FALSE=0, TRUE};$/;"	g
buffer	ripe_attack_generator.h	/^    char buffer[256];$/;"	m	struct:attackme	access:public
buffer	ripe_attack_generator.h	/^  char *buffer;$/;"	m	struct:char_payload	access:public
build_payload	ripe_attack_generator.c	/^boolean build_payload(CHARPAYLOAD *payload) {$/;"	f	signature:(CHARPAYLOAD *payload)
build_payload	ripe_attack_generator.h	/^boolean build_payload(CHARPAYLOAD *payload);$/;"	p	signature:(CHARPAYLOAD *payload)
cf_ret_param	ripe_attack_generator.c	/^static char cf_ret_param[] = "\/tmp\/rip-eval\/f_xxxx";$/;"	v	file:
char_payload	ripe_attack_generator.h	/^struct char_payload {$/;"	s
char_payload::buffer	ripe_attack_generator.h	/^  char *buffer;$/;"	m	struct:char_payload	access:public
char_payload::fake_return_addr	ripe_attack_generator.h	/^  long *fake_return_addr;$/;"	m	struct:char_payload	access:public
char_payload::inject_param	ripe_attack_generator.h	/^  enum inject_params inject_param;$/;"	m	struct:char_payload	typeref:enum:char_payload::inject_params	access:public
char_payload::jmp_buffer	ripe_attack_generator.h	/^  void *jmp_buffer;$/;"	m	struct:char_payload	access:public
char_payload::offset_to_copied_base_ptr	ripe_attack_generator.h	/^  unsigned long offset_to_copied_base_ptr;$/;"	m	struct:char_payload	access:public
char_payload::offset_to_fake_return_addr	ripe_attack_generator.h	/^  unsigned long offset_to_fake_return_addr;$/;"	m	struct:char_payload	access:public
char_payload::overflow_ptr	ripe_attack_generator.h	/^  void *overflow_ptr;  \/* Points to code pointer (direct attack) *\/$/;"	m	struct:char_payload	access:public
char_payload::ptr_to_correct_return_addr	ripe_attack_generator.h	/^  long *ptr_to_correct_return_addr;$/;"	m	struct:char_payload	access:public
char_payload::size	ripe_attack_generator.h	/^  size_t size;$/;"	m	struct:char_payload	access:public
char_payload::stack_jmp_buffer_param	ripe_attack_generator.h	/^  void *stack_jmp_buffer_param;$/;"	m	struct:char_payload	access:public
code_ptr	ripe_attack_generator.h	/^  enum code_ptrs code_ptr;$/;"	m	struct:attack_form	typeref:enum:attack_form::code_ptrs	access:public
code_ptrs	ripe_attack_parameters.h	/^enum code_ptrs     {RET_ADDR=300, OLD_BASE_PTR, $/;"	g
contains_terminating_char	ripe_attack_generator.c	/^boolean contains_terminating_char(unsigned long value) {$/;"	f	signature:(unsigned long value)
contains_terminating_char	ripe_attack_generator.h	/^boolean contains_terminating_char(unsigned long value);$/;"	p	signature:(unsigned long value)
creat	ripe_attack_generator.c	/^int creat(const char *path, mode_t mode){$/;"	f	signature:(const char *path, mode_t mode)
createfile_shellcode	ripe_attack_generator.c	/^static char createfile_shellcode[] = $/;"	v	file:
data_buffer1	ripe_attack_generator.c	/^static char data_buffer1[1] = "d";$/;"	v	file:
data_buffer2	ripe_attack_generator.c	/^static char data_buffer2[128] = "dummy";$/;"	v	file:
data_func_ptr1	ripe_attack_generator.c	/^static int (*data_func_ptr1)(const char *) = &dummy_function;$/;"	v	file:
data_func_ptr2	ripe_attack_generator.c	/^static int (*data_func_ptr2)(const char *) = &dummy_function;$/;"	v	file:
data_jmp_buffer	ripe_attack_generator.c	/^static jmp_buf data_jmp_buffer = {0, 0, 0, 0, 0, 0};$/;"	v	file:
data_mem_ptr	ripe_attack_generator.c	/^static long *data_mem_ptr = 0x0;$/;"	v	file:
data_struct	ripe_attack_generator.c	/^static struct attackme data_struct = {"AAAAAAAAAAAA",&fooz};$/;"	v	typeref:struct:attackme	file:
dummy_function	ripe_attack_generator.h	/^int dummy_function(const char *str) {$/;"	f	signature:(const char *str)
fake_esp_jmpbuff	ripe_attack_generator.c	/^static unsigned long fake_esp_jmpbuff[15] = {$/;"	v	file:
fake_return_addr	ripe_attack_generator.h	/^  long *fake_return_addr;$/;"	m	struct:char_payload	access:public
fooz	ripe_attack_generator.c	/^int fooz(const char *a, int b);$/;"	p	file:	signature:(const char *a, int b)
fooz	ripe_attack_generator.c	/^int fooz(const char *a, int b){$/;"	f	signature:(const char *a, int b)
func_ptr	ripe_attack_generator.h	/^    int (*func_ptr)(const char *, int);$/;"	m	struct:attackme	access:public
function	ripe_attack_generator.h	/^  enum functions function;$/;"	m	struct:attack_form	typeref:enum:attack_form::functions	access:public
functions	ripe_attack_parameters.h	/^enum functions     {MEMCPY=500, STRCPY, STRNCPY, SPRINTF, SNPRINTF,$/;"	g
gadget1	ripe_attack_generator.c	/^void gadget1(int a, int b){$/;"	f	signature:(int a, int b)
gadget1	ripe_attack_generator.h	/^void gadget1(int a, int b);$/;"	p	signature:(int a, int b)
gadget2	ripe_attack_generator.c	/^void gadget2(int a, int b){$/;"	f	signature:(int a, int b)
gadget2	ripe_attack_generator.h	/^void gadget2(int a, int b);$/;"	p	signature:(int a, int b)
gadget3	ripe_attack_generator.c	/^int gadget3(int a, int b){$/;"	f	signature:(int a, int b)
gadget3	ripe_attack_generator.h	/^int  gadget3(int a, int b);$/;"	p	signature:(int a, int b)
has_opened_output_stream	ripe_attack_generator.c	/^static boolean has_opened_output_stream = FALSE;$/;"	v	file:
homebrew_memcpy	ripe_attack_generator.c	/^void homebrew_memcpy(void *dst, const void *src, size_t length) {$/;"	f	signature:(void *dst, const void *src, size_t length)
homebrew_memcpy	ripe_attack_generator.h	/^void homebrew_memcpy(void *dst, const void *src, size_t len);$/;"	p	signature:(void *dst, const void *src, size_t len)
inject_param	ripe_attack_generator.h	/^  enum inject_params inject_param;$/;"	m	struct:attack_form	typeref:enum:attack_form::inject_params	access:public
inject_param	ripe_attack_generator.h	/^  enum inject_params inject_param;$/;"	m	struct:char_payload	typeref:enum:char_payload::inject_params	access:public
inject_params	ripe_attack_parameters.h	/^enum inject_params {INJECTED_CODE_NO_NOP=200, INJECTED_CODE_SIMPLE_NOP,$/;"	g
is_attack_possible	ripe_attack_generator.c	/^boolean is_attack_possible() {$/;"	f
is_attack_possible	ripe_attack_generator.h	/^boolean is_attack_possible();$/;"	p	signature:()
iterator	ripe_attack_generator.c	/^static size_t iterator;$/;"	v	file:
jmp_buffer	ripe_attack_generator.h	/^  void *jmp_buffer;$/;"	m	struct:char_payload	access:public
location	ripe_attack_generator.h	/^  enum locations location;$/;"	m	struct:attack_form	typeref:enum:attack_form::locations	access:public
locations	ripe_attack_parameters.h	/^enum locations     {STACK=400, HEAP, BSS, DATA};$/;"	g
loose_change1	ripe_attack_generator.c	/^static char loose_change1[128];			\/\/NN Sandwich the control vars$/;"	v	file:
loose_change2	ripe_attack_generator.c	/^static char loose_change2[128];			\/\/NN Sandwich the control vars$/;"	v	file:
main	ripe_attack_generator.c	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	ripe_attack_generator.h	/^int main(int argc, char **argv);$/;"	p	signature:(int argc, char **argv)
memory_dump	ripe_attack_generator.h	/^struct memory_dump {$/;"	s
memory_dump::address	ripe_attack_generator.h	/^  char address[HEX_STRING_SIZE];$/;"	m	struct:memory_dump	access:public
memory_dump::value	ripe_attack_generator.h	/^  char value[HEX_STRING_SIZE];$/;"	m	struct:memory_dump	access:public
nr_of_code_ptrs	ripe_attack_parameters.h	/^size_t nr_of_code_ptrs = 16;$/;"	v
nr_of_funcs	ripe_attack_parameters.h	/^size_t nr_of_funcs = 10;$/;"	v
nr_of_inject_params	ripe_attack_parameters.h	/^size_t nr_of_inject_params = 6;$/;"	v
nr_of_locations	ripe_attack_parameters.h	/^size_t nr_of_locations = 4;$/;"	v
nr_of_techniques	ripe_attack_parameters.h	/^size_t nr_of_techniques = 2;$/;"	v
offset_to_copied_base_ptr	ripe_attack_generator.h	/^  unsigned long offset_to_copied_base_ptr;$/;"	m	struct:char_payload	access:public
offset_to_fake_return_addr	ripe_attack_generator.h	/^  unsigned long offset_to_fake_return_addr;$/;"	m	struct:char_payload	access:public
opt_code_ptrs	ripe_attack_parameters.h	/^char *opt_code_ptrs[] = {"ret", "baseptr", $/;"	v
opt_funcs	ripe_attack_parameters.h	/^char *opt_funcs[] = {"memcpy", "strcpy", "strncpy", "sprintf", "snprintf",$/;"	v
opt_inject_params	ripe_attack_parameters.h	/^char *opt_inject_params[] = {"nonop", "simplenop", "polynop",$/;"	v
opt_locations	ripe_attack_parameters.h	/^char *opt_locations[] = {"stack", "heap", "bss", "data"};$/;"	v
opt_techniques	ripe_attack_parameters.h	/^char *opt_techniques[] = {"direct", "indirect"};$/;"	v
output_debug_info	ripe_attack_generator.c	/^static boolean output_debug_info = FALSE; \/* Disables most effective attacks *\/$/;"	v	file:
output_error_msg	ripe_attack_generator.c	/^static boolean output_error_msg = TRUE;$/;"	v	file:
overflow_ptr	ripe_attack_generator.h	/^  void *overflow_ptr;  \/* Points to code pointer (direct attack) *\/$/;"	m	struct:char_payload	access:public
perform_attack	ripe_attack_generator.c	/^void perform_attack(FILE *output_stream,$/;"	f	signature:(FILE *output_stream, int (*stack_func_ptr_param)(const char *), jmp_buf stack_jmp_buffer_param)
perform_attack	ripe_attack_generator.h	/^void perform_attack(FILE *output_stream,$/;"	p	signature:(FILE *output_stream, int (*stack_func_ptr_param)(const char *), jmp_buf stack_jmp_buffer_param)
pointer	ripe_attack_generator.c	/^static char *pointer;  \/\/ Global to leave stack untouched$/;"	v	file:
print_memory	ripe_attack_generator.c	/^void print_memory(FILE *stream, char *start, size_t words) {$/;"	f	signature:(FILE *stream, char *start, size_t words)
print_memory	ripe_attack_generator.h	/^void print_memory(FILE *stream, char *start, size_t words);$/;"	p	signature:(FILE *stream, char *start, size_t words)
print_payload_info	ripe_attack_generator.c	/^void print_payload_info(FILE *stream, CHARPAYLOAD *payload) {$/;"	f	signature:(FILE *stream, CHARPAYLOAD *payload)
print_payload_info	ripe_attack_generator.h	/^void print_payload_info(FILE *stream, CHARPAYLOAD *payload);$/;"	p	signature:(FILE *stream, CHARPAYLOAD *payload)
print_three_memory_dumps	ripe_attack_generator.c	/^void print_three_memory_dumps(FILE *stream,$/;"	f	signature:(FILE *stream, MEM_DUMP *dump1, MEM_DUMP *dump2, MEM_DUMP *dump3, size_t size)
print_three_memory_dumps	ripe_attack_generator.h	/^void print_three_memory_dumps(FILE *stream,$/;"	p	signature:(FILE *stream, struct memory_dump *dump1, struct memory_dump *dump2, struct memory_dump *dump3, size_t size)
print_two_memory_dumps	ripe_attack_generator.c	/^void print_two_memory_dumps(FILE *stream,$/;"	f	signature:(FILE *stream, MEM_DUMP *dump1, MEM_DUMP *dump2, size_t size)
print_two_memory_dumps	ripe_attack_generator.h	/^void print_two_memory_dumps(FILE *stream,$/;"	p	signature:(FILE *stream, struct memory_dump *dump1, struct memory_dump *dump2, size_t size)
ptr_to_correct_return_addr	ripe_attack_generator.h	/^  long *ptr_to_correct_return_addr;$/;"	m	struct:char_payload	access:public
remove_all_terminating_chars	ripe_attack_generator.c	/^void remove_all_terminating_chars(char *contents, size_t length) {$/;"	f	signature:(char *contents, size_t length)
remove_nulls	ripe_attack_generator.c	/^void remove_nulls(char *contents, size_t length) {$/;"	f	signature:(char *contents, size_t length)
remove_nulls	ripe_attack_generator.h	/^void remove_nulls(char *contents, size_t length);$/;"	p	signature:(char *contents, size_t length)
remove_terminating_chars	ripe_attack_generator.h	/^void remove_terminating_chars(char *contents, size_t length);$/;"	p	signature:(char *contents, size_t length)
ripe_attack_generator.c	ripe_attack_generator.c	1;"	F
ripe_attack_generator.h	ripe_attack_generator.h	1;"	F
ripe_attack_parameters.h	ripe_attack_parameters.h	1;"	F
rop_sled	ripe_attack_generator.c	/^static unsigned long rop_sled[7] = {$/;"	v	file:
save_memory	ripe_attack_generator.c	/^void save_memory(MEM_DUMP *dump, char *start, size_t size) {$/;"	f	signature:(MEM_DUMP *dump, char *start, size_t size)
save_memory	ripe_attack_generator.h	/^void save_memory(struct memory_dump *dump, char *start, size_t size);$/;"	p	signature:(struct memory_dump *dump, char *start, size_t size)
set_code_ptr	ripe_attack_generator.c	/^void set_code_ptr(char *choice) {$/;"	f	signature:(char *choice)
set_code_ptr	ripe_attack_generator.h	/^void set_code_ptr(char *choice);$/;"	p	signature:(char *choice)
set_function	ripe_attack_generator.c	/^void set_function(char *choice) {$/;"	f	signature:(char *choice)
set_function	ripe_attack_generator.h	/^void set_function(char *choice);$/;"	p	signature:(char *choice)
set_inject_param	ripe_attack_generator.c	/^void set_inject_param(char *choice) {$/;"	f	signature:(char *choice)
set_inject_param	ripe_attack_generator.h	/^void set_inject_param(char *choice);$/;"	p	signature:(char *choice)
set_location	ripe_attack_generator.c	/^void set_location(char *choice) {$/;"	f	signature:(char *choice)
set_location	ripe_attack_generator.h	/^void set_location(char *choice);$/;"	p	signature:(char *choice)
set_technique	ripe_attack_generator.c	/^void set_technique(char *choice) {$/;"	f	signature:(char *choice)
set_technique	ripe_attack_generator.h	/^void set_technique(char *choice);$/;"	p	signature:(char *choice)
shellcode_nonop	ripe_attack_generator.c	/^static char shellcode_nonop[] = $/;"	v	file:
shellcode_polynop	ripe_attack_generator.c	/^static char shellcode_polynop[] =$/;"	v	file:
shellcode_simplenop	ripe_attack_generator.c	/^static char shellcode_simplenop[] =$/;"	v	file:
size	ripe_attack_generator.h	/^  size_t size;$/;"	m	struct:char_payload	access:public
size_shellcode_createfile	ripe_attack_generator.c	/^static size_t size_shellcode_createfile = sizeof(createfile_shellcode) \/ sizeof(createfile_shellcode[0]) - 1;$/;"	v	file:
size_shellcode_nonop	ripe_attack_generator.c	/^static size_t size_shellcode_nonop = sizeof(shellcode_nonop) \/ sizeof(shellcode_nonop[0]) - 1;  \/\/ Do not count for the null terminator since a null in the shellcode will terminate any string function in the standard library$/;"	v	file:
size_shellcode_polynop	ripe_attack_generator.c	/^static size_t  size_shellcode_polynop =$/;"	v	file:
size_shellcode_simplenop	ripe_attack_generator.c	/^static size_t size_shellcode_simplenop = sizeof(shellcode_simplenop) \/ sizeof(shellcode_simplenop[0]) - 1;  \/\/ Do not count for the null terminator since a null in the shellcode will terminate any string function in the standard library$/;"	v	file:
sleep	ripe_attack_generator.c	/^unsigned sleep(unsigned secs){$/;"	f	signature:(unsigned secs)
space_for_stack_growth	ripe_attack_generator.c	/^static char space_for_stack_growth[1024] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";$/;"	v	file:
stack_jmp_buffer_param	ripe_attack_generator.h	/^  void *stack_jmp_buffer_param;$/;"	m	struct:char_payload	access:public
technique	ripe_attack_generator.h	/^  enum techniques technique;$/;"	m	struct:attack_form	typeref:enum:attack_form::techniques	access:public
techniques	ripe_attack_parameters.h	/^enum techniques    {DIRECT=100, INDIRECT};$/;"	g
value	ripe_attack_generator.h	/^  char value[HEX_STRING_SIZE];$/;"	m	struct:memory_dump	access:public
